N = 6 #число предметов
A = [0,0.1,0.2,0.3,0.7,0.8,0.9] # размеры предметов
V = [0]*N # заполненность контейнеров
Box = 0 #кол-во контейнеров в текущей упаковке
OptBox = 0 #кол-во контейнеров в оптимальной упаковке
Cont = [0]*N #текущая упаковка
OptCont = [0]*N #оптимальная упаковка (ее как раз надо найти)


def pack(i,Box,OptBox,N):
    eps = A[i]*0.1 #некоторое маленькое число (его можно считать = 0)
    for j in range(1,N):
        if V[j] <= eps and (Box+1)>=OptBox: #если контейнер j пуст и кол-во контейнеров в текущей упаковке уже превышает оптимальное кол-во, то выходим
            break
        if V[j]+A[i] <= 1+eps: #если контейнер не 1 и предыдущий контейнер пустой то выходим
            break
        if V[j] +A[i] <= 1+eps: #если заполненость контейнера + размер предмета меньше 1 (т.е туда можно положить предмет)
            B = Box # в В записываем кол-во кол-во контейнеров в текущей упаковке
        if V[j] <= eps: # если пустой, то увеличиваем кол-во контейнеров в этой упаковке на 1
            Box += 1
        V[j] += A[i] #заполняем j контейнер на объем i предмета
        Cont[i] = j #предмет i помещаем   в j контейнер
        if i<N: #если текущий предмет не последний, то вызываем рекурсию и пытаемся упаковать след предмет
            pack(i+1,Box,OptBox,N)
        else: #если нет, то
            OptBox = Box #в оптим присваиваем текущее кол-во контейнеров в упаковке
            for k in range(N+1): # в оптимальную упаковку = текущую упаковку
                OptCont[k] = Cont[k]
            Box = B #возвращаем старое старое значение контейнеров в упаковке
            Cont[i] = 0 #выкидываем текущий предмет
            V[j] -= A[i] # вычитаем объем текущего предмета

# main
for i in range(0,N):
    V[i] = 0 #все контейнеры очищаем
    Cont[i] = 0 # все предметы никуда не помещены (лежат в сторонке)
    OptCont[i] = i # оптимальное кол-во контейнеров в упаковке = N (тут чуть неуверен)
OptBox = N # пока оптимально поместить каждый предмет в свой контейнер)
Cont[1] = 1 # первый предмет упаковываем в 1 вагон
V[1] = A[1] # увеличиваем заполненность 1го контейнера на размер 1го предмета
Box = 1 # кол-во контейнеров в текущей упаковке =1
pack(2,Box,OptBox,N) # упаковываем второй предмет
print(OptCont)







